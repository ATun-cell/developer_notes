**ThreadLocal作用**
ThreadLocal类允许每个线程绑定自己的值，创建一个ThreadLocal变量时，每个访问变量的线程都会拥有一个独立的副本

**ThreadLocal原理**
底层调用当前线程私有的**`ThreadLocalMap`** 这个数据结构是HashMap。每个线程都拥有一个`ThreadLocalMap` 可以存储线程ThreadLocal对象实例为key，Object对象为value的键值对

**ThreadLocal内存泄漏问题是怎么导致的**
ThreadLocalMap中的key是ThreadLocal的弱引用，意味着如果Threadlocal实例不在被任何强指引指向，垃圾回收器会在下次GC时回收该实例，导致key变为null
当ThreadLocal实例失去强引用后，其对应的value仍然存在，因为是强引用。导致key为null的entry无法被垃圾回收，造成内存泄漏

两个条件
 - 实例失去强引用
 - 线程持续存活

**如何避免内存泄漏的发生**
使用完ThreadLocal后要调用remove()方法
在线程池等线程复用场景下，使用try-finally保证remove()方法被默认执行

**如何跨线程传递ThreadLocal值**
- InheritableThreadLocal类，会在创建子线程时，子线程继承父线程中的ThreadLocal值，但是不支持线程池场景的ThreadLocal值传递
- TransmittableThreadLocal 继承了InheritableThreadLocal类并且可以在线程池场景下传递值

**应用场景**
压测流量标记
上下文传递




**什么时线程池**
管理一系列线程的资源池，需要时直接从池里获取，不需要时放回池里而不会销毁，减少创建开销

**为什么要用线程池**
- 降低资源消耗
- 提高相应速度
- 提高线程的可管理性，保证系统稳定性


**创建线程池方式**
通过ThreadPoolExecutor直接创建，允许开发者明确指定线程池的核心参数，更加明确线程池运行规则，避免资源耗尽的风险

通过工具类Executors创建

**为什么不推荐使用内置线程池**
工具类Executors创建的线程池使用的队列可以看作是无界的，容易堆积大量请求，造成资源耗尽


ThreadPoolExecutor三个最重要的参数：
- 核心线程数，任务队列未达到队列容量时最大可以同时运行的线程数量
- 最大线程数
- 任务队列，新任务来的时候如果运行的线程达到核心线程数，新任务会被放到队列中
核心线程会长期保持活跃，即使空闲。可以由参数控制关闭

**线程池的拒绝策略**

不允许丢弃任务，应该选择CallerRunsPolicy，保证任何一个任务请求都要被执行

**CallerRunsPolicy有什么风险**
如果任务很耗时，且提交任务的线程是主线程可能会导致阻塞

任务持久化策略
入库
入缓存
入消息队列

项目中用到的就是这个CallerRunsPolicy策略

**线程池处理任务的流程了解吗**
如果当前运行的线程数小于核心线程数，就会拉取一个线程来执行任务
如果核心线程池已满，会看等待队列是否满，如果没满会把任务放进等待队列
如果任务队列已经满了，会判断最大线程池是否已满，没有满就新建一个线程来执行任务
如果线程数达到最大线程数，会更具拒绝策略处理

**线程池在提交任务之前可以提前创建线程吗**
可以完成核心线程的创建从而实现线程池预热的效果，当然默认情况是懒创建，由任务提交到线程池才进行核心线程的创建

**如何设定线程池的大小**
IO密集任务线程数量一般是CPU核心数量的2倍
CPU密集型任务一般是核心数量的N+1，避免频繁的上下文切换


**Future类有什么用**
多线程下异步任务实现，耗时任务交给子线程执行，主线程继续执行，耗时任务执行结束后再返回结果。

**CompletableFuture类什么作用**
完成异步任务编排，可以将多个异步任务串联起来

**一个任务需要依赖另外两个任务执行完再执行怎么设计**
适合通过CompletableFuture类实现

**AQS是什么**
抽象队列同步器，解决实现同步器时的复杂性。提供一个通用框架用于实现各种同步器。例如可重入锁、信号量、和倒计时器。通过封装底层的线程同步机制，简化开发步骤。是一个抽象类，定义资源获取和释放的通用流程，是一个构建锁和其它同步器的模板抽象类

**AQS的原理是什么**
它通过**一个 volatile 的 int 状态变量（state）** 和 **一个 FIFO 等待队列（CLH 队列）** 来实现线程的同步访问控制。这个CLH队列是一个双向队列，暂时获取不到锁的线程被加入到该队列中。
每个请求共享资源的线程封装成一个CLH队列的一个结点来实现锁的分配

AQS还通过一个 volatile 的 int 状态变量（state）作为共享状态，用于展示当前临界资源的获锁

以Reentrantlock为例，state初始值为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state加1。此后其它线程被阻塞，知道A线程unlock()使state=0。当然释放锁之前A线程自己使可以重复获取此锁，state会累加，但是要注意获取多少次就要释放多少次


**Semaphore（信号量）有什么用**
`synchronized` 和 `ReentrantLock` 都是一次只允许一个线程访问某个资源，而`Semaphore`(信号量)可以用来控制同时访问特定资源的线程数量。
可以通过构造器指定是公平模式还是非公平模式
通过AQS实现共享资源的认证逻辑

**CountDownLatch有什么用**
允许count个线程阻塞再一个地方，直至所有线程的任务都执行完毕

**CountDownLatch原理是什么**
是共享锁的一种实现，默认构造AQS的state值为count。线程使用countDown()方法时以CAS操作来减少state，知道state为0。