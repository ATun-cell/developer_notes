
线程之间共享堆和字符串常量池，但是独享虚拟机栈、本地方法栈和程序计数器
**为什么线程私有程序计数器**
- 字节码解释器通过改变程序计数器依次读取指令从而实现代码得流程控制
- 在多线程下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道改线程上次运行得位置

主要是为了线程切换后能恢复到正确的执行位置

**虚拟机栈和方法栈为什么是私有的**
*虚拟机* 每个Java方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在Java虚拟机中入栈和出栈得过程
*本地方法栈* 和虚拟机栈发挥的作用非常相似
所以为了是为了保证线程中得局部变量不被别的线程被访问到

**一句话了解堆和方法区**
堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要存放新创建得对象，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

**如何创建线程**
继承Thread类、实现Runnable接口、实现Callable接口、使用线程池、使用ComletableFuture类等
不过Java中创建线程的底层原理都是new Thread().start()创建。

**说说线程的生命周期和状态**
Java线程在运行的生命周期中的某一时刻只能处于六种状态中的一个状态
- NEW，初始状态，线程被创建出来但没有被调用start()
- RUNNABLE，运行状态，线程被调用了start()等待运行的状态
- BLOCKED，阻塞状态，需要等待锁释放
- WAITING，等待状态，便是线程需要等待其它线程做出一个特定动作
- TIME_WAITING，超时等待状态，可以在指定的事件后自行返回
- TERMINATER，终止状态，表示该线程已经运行完毕

**Thread的sleep()方法和Object的wait()方法对比**
都可以暂停线程的执行
- 但是sleep没有 释放锁，而wait释放了锁
- wait常被用于线程间交互，sleep用于暂停线程
- sleep时Thread类的静态本地方法，wait时Object类的本地方法


**为什么wait方法不定义在Thread中**
wait是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象都拥有对象锁，既然要释放当前线程占有的对象锁让其进入WAITING状态，自然是操作对应的对象而不是当前的线程
而sleep是让当前线程暂停执行不涉及到对象类，也不需要获得对象锁

**可以直接调用Thread类的run方法吗**
不会，直接调用run方法，会把它当作是主线程的一个普通方法。使用前需要new Thread()创建子线程

**同步和异步的区别**
同步时调用发出后必须等待其它线程的结果才能返回
异步是调用发出后不用等待结果直接返回

**为什么使用多线程**
多核CPU给多线程带来硬件遍历，减少很多线程上下文切换的开销
从当代互联网的发展需求，多线程并发是高并发系统的基础
提高单核和多核CPU的运行效率
IO线程的阻塞


**单核CPU支持Java多线程吗**
支持，可以通过时间片轮转的方式切换线程，快速的在多个线程之间切换
 主要用过两种线程调度方式来管理多线程的执行
 - *抢占式调度*  操作系统决定何时切换线程，系统时钟中断触发，存在上下文开销但公平性和CPU利用率高 Java的线程调度就是这种方式
 - *协同式调度*  线程执行完毕后通知系统切换线程，可以减少上下文切换带来的性能开销但公平性较差

**单核CPU运行多个线程效率一定会高吗**
取决于线程的类型，
- *CPU密集型* 
- *IO密集型*
CPU密集型多个线程的上下文切换会增加系统开销。IO密集型多个线程同时运行可以利用CPU在IO时的空闲时间，提高运行效率

**使用多线程可能带来什么问题**
内存泄漏、死锁、线程不安全

**如何理解线程不安全**
多线程环境下对于同一份数据的访问是否能保证其一致性和正确性

**死锁**
多个线程同时无限期被阻塞，一个或者全部都在等待某个资源被释放

死锁产生的四个条件 （独占资源，不主动释放不强行剥夺，循环等待）
- *互斥条件*  该资源任意一个时刻只有一个线程占用
- *请求与保持条件*  一个线程因请求资源而阻塞时，对已获得的资源保持不放
- *不剥夺条件*  线程以获得的资源在未使用之前不能被其它线程强行剥夺，只有自己主动释放
- *循环等待条件*  多线程之间形成一个头尾相接的循环等待资源关系

**如何检测死锁**
使用JConsole工具进行检测

**如何预防和避免线程死锁**
*预防死锁*
- 破坏请求与保持 一次性申请所有资源
- 破坏不剥夺 申请不到资源可以主动释放自己占有的资源
- 破坏循环等待 按某一顺序申请资源，释放资源则反序释放

**如何避免死锁**
避免死锁就是在资源分配时借助算发对资源分配进行计算评估，使其进入安全状态