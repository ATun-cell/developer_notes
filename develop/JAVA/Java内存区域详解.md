知道Java是怎么使用内存的，有助于解决内存泄漏和溢出方面的问题

![[Pasted image 20250624142156.png]]

堆、方法区、和直接内存是共享的。堆可以是连续空间也可以不连续，堆的大小可以固定也可以按需扩展。

Java虚拟机栈实现方法调用。栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。
![[Pasted image 20250624143659.png]]

栈可能会报StackOverFlowError错误或者OutOfMemoryError错误
- 栈的内存大小不允许动态扩展，当线程请求栈的深度超过最大深度，就会抛出StackOverFlowError异常
- 栈的内存大小可以动态扩展，当虚拟机在动态栈无法申请到足够的内存空间，抛出OutOfMemoryError异常

![[Pasted image 20250624144151.png]]

**堆**
是所有线程共享的一块内存区域，唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存

Java堆是垃圾收集器管理的主要区域，因此也叫做GC堆

堆最常报的错误就是OOM错误、
![[Pasted image 20250624144714.png]]

**方法区**
是一块逻辑区域，各个线程共享的内存区域
虚拟机要使用一个类时，会首先解析Class文件获取相关信息，再将信息存入到方法区包括类信息，字段信息，方法信息，常量，静态变量

方法区只是抽象规范，具体实现是元空间，使用的是本地内存

**运行时常量池**
Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（固定值）和符号引用的常量池表
常量池表会再类加载后存放到方法区的运行时常量池中

**字符串常量池**
为了提升性能和减少内存消耗堆字符串专门开辟的一块区域，避免字符串的重复创建


**对象的创建过程**
1. *类加载检查*，检查运行时常量池的符号引用，以及这个符号引用代表的类是否以被加载过，如果没有需要先执行相应的类加载过程
2. *分配内存*，分配方式有指针碰撞和空闲列表两者![[Pasted image 20250624150630.png]]
	分配内存时需要保证线程安全，有两种方式。CAS+失败重试和TLAB
3. *初始化零值*，将分配到的内存空间都初始化为零值不包括对头
4. *设置对象头*，对对象进行必要的设置，将对象是哪个类的实例、如何才能找到类的元数据信息等信息存放在对象头种
5. *执行Init方法*，初始化属性


**对象的内存布局**
