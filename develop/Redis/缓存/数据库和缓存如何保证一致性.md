Cache Aside策略，旁路缓存策略，更新数据时不更新缓存而是删除缓存中的数据，读取数据时发现缓存中没了数据之后，再从数据库中读取数据更新到缓存中

如果业务对缓存命中率由很高的要求，可以采用更新数据库+更新缓存的方案，因为更新缓存不会出现缓存未命中的情况

但是这样两个线程并发更新他们的话就会因为写入顺序的不同造成数据的不一致
- 在更新缓存前先设置分布式锁，保证同一时间只允许一个请求更新缓存，就不会产生并发问题了
- 更新完缓存时，给缓存加上较短的过期时间

旁路缓存策略一般是先更新数据库，再删缓存。但是如果删缓存操作是白，那么客户段请求的还是旧缓存值，导致数据不一致问题。有两个方案解决这个问题
## 消息队列重试机制
引入消息队列，将删除缓存要操作的数据加入到消息队列，由消费者来操作数据
- 如果应用删除缓存失败，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是重试机制
- 如果删除缓存成功，就要把数据从消息队列中移除，避免重复操作

## 订阅MySQL binlog，再操作缓存
更新数据库成功就会产生一条变更日志，记录在binlog里
就可以通过订阅binlog日志拿到具体要操作的数据然后再执行缓存删除。具体的实现由阿里巴巴开源的Canal中间件



这两种方法斗是采用异步操作缓存