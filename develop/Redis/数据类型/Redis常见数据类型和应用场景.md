# String
最常见的key-value结构，key是唯一标识，value是具体的值，value不仅是字符串也可以是数字，最多可以容纳的数据长度是512m
## 内部实现
实现主要是int和SDS(简单动态字符串)
![[Pasted image 20250520203616.png]]
## 常用指令
![[Pasted image 20250520204122.png]]
![[Pasted image 20250520204344.png]]
![[Pasted image 20250520204723.png]]
![[Pasted image 20250520204758.png]]
## 应用场景
### 缓存对象
![[Pasted image 20250520210435.png]]
### 常规计数
![[Pasted image 20250520211537.png]]
### 分布式锁
![[Pasted image 20250520214006.png]]
### 共享session信息
开发时，使用Session来保存用户的会话登录状态，这些信息如果被保存在服务器中，分布式系统每次会把请求随机分配到不同的服务器，如果被分配的服务器中没有对应用户的Session信息，则需要重新登录。
因此需要借助Redis对这些Session信息进行统一的存储和管理，这样无论请求发送到哪台服务器，都会去同一个Redis获取相关的Session信息
****
# List
****
简单的字符串裂变，按照插入顺序排序，可以从头部或尾部添加元素，最大长度为2^32-1
## 内部实现
双向链表或压缩列表
- 列表的元素个数小于512个，每个元素的值斗小于64字节，使用压缩列表作为List类型的底层数据结构
- 不满足上面条件，使用双向链表
- 3.2版本之后这两个被quicklist代替
## 常用命令
![[Pasted image 20250520214837.png]]
## 应用场景
### 消息队列
消息队列必须要满足三个需求，分别是消息保序、处理重复的消息、保证消息可靠性
1. 如何满足消息保序需求
	![[Pasted image 20250520215310.png]]
2. 如何处理重复的消息
	需要每个消息都有一个全局的ID，消费者要记录已经处理过的消息ID
	List不会为每个消息生成ID号，需要我们自行为每个消息生成一个全局唯一ID
3. 如何保证消息可靠性
	如果消费者读了消息但没能正常处理，List不会留存这条信息
	为了留存信息，List类型提供了BRPOPLPUSH命令，作用是让消费者程序从一个LIst中读取信息，同时Redis会把这个消息再插入到另一个List留存
缺点：
- 不支持多个消费者消费同一条信息
****
# Hash
****
键值对集合，其中value的形式：value=[ { field1, value1}, .....{fieldN, valueN } ]
特别适合存储对象
redis7.0版本后，交由listpack数据结构来实现
## 常用命令
![[Pasted image 20250521095805.png]]
## 应用场景
### 存储对象
### 购物车
用户id为key，商品为field，商品数量为value，
![[Pasted image 20250521100112.png]]
****
# Set
****
无序并唯一的键值集合
内部实现如果集合中的元素斗是整数且个数小于512，使用整数集合。不满足上面条件，使用哈希表

## 常用命令
![[Pasted image 20250521100503.png]]
## 应用场景
用来数据去重和保障数据唯一性
点赞
共同关注
抽奖活动
****
# Zset
****
有序集合，比Set多了排序属性的score
内部实现是listpack
## 常用命令
![[Pasted image 20250521101317.png]]
## 应用场景
排行榜
电话、姓名排序
****
# Bit
连续的二进制数组，通过偏移量定位元素，
内部实现是String类型的字节数组
![[Pasted image 20250521103032.png]]
## 应用场景
签到统计
判断用户登录状态
连续签到用户总数
****
# HyperLogLog
海量数据基数统计

# GEO
存储地理位置信息

# Stream
消息队列，又两个特有特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。
适合小规模消息存储