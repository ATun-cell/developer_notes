![[Pasted image 20250521103600.png]]
# 键值对数据库是怎么实现的
Redis是使用了一个哈希表保存所有键值对。hash表就是一个数组，数组中的元素叫做哈希桶
![[Pasted image 20250521105126.png]]

# SDS
C语言字符串是一个字符数组，时间复杂度是O(N)，且不能保存二进制数据，字符串的操作函数容易导致缓冲区溢出
SDS把这些问题解决了
![[Pasted image 20250521105726.png]]
![[Pasted image 20250521105807.png]]

# 链表
C语言本身没有链表，Redis自己设计了一个链表数据结构
![[Pasted image 20250521110221.png]]
![[Pasted image 20250521110332.png]]

# 压缩列表

# 哈希表
每个key都是独一无二的，将key通过Hash函数的计算，就能定位到数据在表中的位置，哈希表实际上是数组，所以可以通过索引值快速查询到数据
哈希表固定的情况下，数据不断增多，哈希冲突的可能性也会越高。Redis采用链式哈希来解决哈希冲突，不扩容的前提下，将具有相同哈希值的数据穿起来，形成连接

##  哈希冲突
![[Pasted image 20250521145922.png]]
两个以上数量的key被分配到了哈希表中同一个哈希桶上时，此时称这些key发生了冲突

## 链式哈希
![[Pasted image 20250521150234.png]]

## rehash
redis实际使用hash表时，定义了一个dict结构体，里面定义了两个哈希表，为了进行rehash

正常服务请求阶段，插入的数据都会写道哈希表1，此时的哈希表2没有被分配空间。随着数据逐步增多，出发了rehash操作
- 给哈希表2分配空间，一般会比哈希表1大一倍
- 将哈希表1的数据迁移到哈希表2中
- 迁移后，哈希表1的空间会被释放，并把哈希表2设置为哈希表1，然后再哈希表2新创建一个空白的哈希表，为下一次rehash作准备

## 渐进式rehash
rehash数据的迁移工作不是一次性迁移完成，而是分多次迁移
![[Pasted image 20250521151130.png]]

****
# 整数集合
****
当一个Set对象只包含整数值元素，并且元素数量不大时，就会使用整数合集
本质上是一块连续内存空间，保存元素的容器是一个contents数组

## 整数集合的升级操作
跳过

# 跳表
****
只有Zset对象使用到，优势是能支持平均O(logN)复杂度的节点查找
![[Pasted image 20250521152453.png]]

## 跳表结构设计
链表查找元素的时间复杂度是O(N)，于是就出现了跳表。实现了一种多层的有序链表，这样的好处是能快速定位数据
![[Pasted image 20250521152826.png]]

## 跳表节点查询过程
![[Pasted image 20250521153730.png]]

## 跳表节点层数设置
![[Pasted image 20250521154539.png]]

## 为什么用跳表而不用平衡树
- 从内存占用，跳表更灵活：平衡树每个节点包含两个指针。跳表每个节点包含的指针数目平均为1/（1-p），
- 范围查找的时候，操作更简单
- 算法实现难度上比较简单。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，跳表的插入和删除只需要i需改相邻节点的指针

# quicklist
****
![[Pasted image 20250521155413.png]]

# listpack
****
![[Pasted image 20250521155633.png]]