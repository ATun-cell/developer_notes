# 全局锁
****
上锁后整个数据库处于只读状态
## 应用场景
用于全库逻辑备份
## 缺点
造成业务停滞

## 怎么避免
如果支持可重复读的隔离级别，在备份数据库之间先开启事务，由于MVCC的支持，在备份期间依然可以对数据进行更新

# 表级锁
****
- 表锁
- 元数据锁
- 意向锁
- AUTO-INC锁
## 表锁
![[Pasted image 20250514150741.png]]
表锁除了会限制别的线程的读写，也会限制本线程接下来的读写操作

会话退出后，也会释放所有表锁

## 元数据锁（MDL）
- 对一个表进行CRUD操作时，加的是MDL读锁
- 对一个表做结构变更操作的时候，假的是MDL写锁

MDL是在事务提交后才会释放，如果一直不释放，其它事务的读操作不会阻塞，写操作会阻塞，并且这个阻塞会导致其它事务的读操作阻塞。因为申请MDL锁会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现MDL写锁等待，会阻塞后续该表的所有CRUD操作

## 意向锁
![[Pasted image 20250514183247.png]]
## AUTO-INC锁
通过对主键字段声明AUTO_INCREMENT属性实现主键的自增，这主要是通过AUTO-INC锁实现的
是特殊的表锁机制，锁不是一个事务提交后才释放的，而是执行完插入语句就会立即释放

由于大量数据进行插入的时候会影响性能，索引存储引擎提供了一种轻量级的锁来实现自增

# 行级锁
共享锁满足读读共享，读写互斥。独占锁满足写写互斥，读写互斥
## Record Lock
记录锁，锁住的是一条记录。当事务提交后，事务过程中生成的锁都会被释放

## Gap Lock
间隙锁，是为了解决可重复读隔离级别下的幻读的现象
假设表中有一个范围id为（3， 5）间隙锁，那么其它事务就无法插入id=4这条记录了，这样就有效的防止幻读现象的发生
间隙锁之间是兼容的，两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的

## Next-Key Lock
称为临键锁，上面两个行锁的结合，锁定一个范围，并且锁定记录本身

## 插入意向锁
一个事务在插入一条记录的时候，需要判断插入位置是否已被其它事务加了间隙锁
如果有的话，插入操作就会发生阻塞，再次期间会生成一个插入意向锁，表明有事务在某个区间插入新纪录，但是现在处于等待状态
