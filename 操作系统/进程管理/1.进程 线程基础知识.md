# 进程
****

![[Pasted image 20250506203933.png]]
进程有运行-->暂停-->运行的活动规律

## 进程的状态
进程共有五个状态
- 创建状态(new):进程正在被创建时的状态
- 结束状态(Exit):进程正在从系统消失时的状态
- 运行状态(Running):该时刻进程占用CPU
- 就绪状态(Ready):可运行,由于其它进程而暂停运行
- 阻塞状态(Blocked):该进程正在等待某一事件的发生而暂停运行,这是,即使给他CPU控制权,也无法运行
![[Pasted image 20250506204541.png]]

另外为解决大量进程处于阻塞状态,还有一种挂起状态
- 阻带挂起状态:进程在外存(硬盘)并等待某个事件的出现
- 就绪挂起状态:进程在外存(硬盘),但只要进入内存,立即开始运行
![[Pasted image 20250506204950.png]]
## 进程的控制结构
用进程控制块(PCB)数据结构来描述进程.PCB是进程存在的唯一标识
PCB包含的信息
- 进程描述信息
	- 进程标识符
	- 用户标识符
- 进程控制和管理信息
	- 进程当前状态
	- 进程优先级
- 资源分配清单
	- 有关内存地址或虚拟地址空间的信息,所打开文件的列表和所使用的I/O设备信息
- CPU相关信息
	- CPU中各个寄存器的值,当进程被切换时,CPU的状态信息都会保存在相应的PCB中,以便进程重新执行

PCB通常是通过链表的方式进行组织,把具有相同状态的进程连在一起

## 进程的控制

1. 创建进程
	操作系统允许一个进程创建另一个进程,允许子进程集成父进程拥有的资源
	过程如下
	- 申请一个空白的PCB,然后向其填写一些控制喝管理进程的信息,比如进程 的唯一标识
	- 为该进程分配运行时所必须的资源,比如内存资源
	- 将PCB插入到就绪队列,等待被调度运行
2. 终止进程
	有三种方式,正常结束,异常结束外界干预
	当紫禁城被终止时,在父进程继承的资源会还回去
	过程如下
	- 查找需要终止的进程的PCB
	- 如果处于执行状态,则离职终止执行,然后将CPU资源分配给其它进程
	- 如果其还有子进程,则将子进程交给1好进程接管
	- 将该进程所拥有的所有资源斗归还给系统
	- 将其从PCB所在队列中删除
3. 阻塞进程
	进程需要等待某一事件完成时,它可以调用阻塞语句把自己阻塞等待,而一旦被阻塞等待,只能由另一个进程唤醒
	过程如下
	- 找到PCB
	- 如果该进程为运行状态,则保护其线程,状态转为阻塞,停止运行
	- PCB插入到阻塞队列中
4. 唤醒进程
	过程如下
	- 阻塞队列中找到相印PCB
	- 将其从阻塞队列中移除,状态转为就绪装填
	- PCB插入到就绪队列中,等待调度程序调度
	进程的阻塞和唤醒是一对功能相反的语句,如果某个进程调用了阻塞语句,则必须有一个与之对应的唤醒语句

## 进程的上下文切换
讨论CPU如何进行不同进程的切换,保存交换的信息,当重新开始运行的时候需要从这个进程PCB中取出上下文,然后恢复到CPU中,使得这个进程可以继续执行
![[Pasted image 20250507104033.png]]

****
# 线程
****
*更小的独立运行基本单位*
## 为什么使用线程
为了程序多函数的并发执行,多进程的系统开销大,所以创造出线程
- 可以并发运行
- 共享相同的地址空间

## 什么是线程
*线程是进程当中的一条执行流程*
同一个进程内多个线程之间可以共享代码段,数据段,打开的文件等资源,但每个线程各自都有一套独立的寄存器和栈,这样可以确保线程的控制流是相对独立的
**线程的缺点**
- 当一个进程中的一个线程崩溃时,会导致其所属进程的所有线程崩溃(这里是针对C/C++语言,Java语言中的线程不会造成进程崩溃)

## 线程和进程的比较
- 进程是资源(内存,打开的文件等)分配的单位,线程是CPU调度的单位
- 进程拥有一个完整的资源频台,而线程只独享必不可少的资源,如寄存器和栈
- 线程同样具有就绪,阻塞,执行三种基本状态,同样具有状态之间的转换关系
- 线程能减少并发执行的时间和空间开销
	-  线程的创建事件比进程快,因为进程创建时还需要资源管理信息,而进程不会设计这些资源管理信息,而是共享他们
	- 线程的终止时间比进程快,因为线程释放的资源相比进程少很多
	- 同一个进程内的线程切换比进程切换快,因为线程具有相同的地址(虚拟内存共享),这意味着同一个线程的进程都具有同一个页表,那么在切换的时候不需要切换页表.而对于进程之间的切换,切换的时候要把页表给切换掉,而页表的切换过程开销是比较大的
	- 由于同一进程的个线程共享内存和文件资源,那么在线程之间数据穿滴的时候,就不需要经过内核了,这就使得线程之间的数据交互效率更高了

## 线程的上下文切换
所谓操作系统的任务调度,调度的知识线程,而进程知识给线程提供了虚拟内存,全局变量等资源
可以这么理解
- 进程只有一个线程时,可以认为进程就等于线程
- 进程拥有多个线程时,线程会共享相同的虚拟内存和全局变量等资源,这些资源在上下文切换时是不需要修改的
线程的上下文切换
- 两个线程不数据用一个进程,切换的过程就更进程上下文切换一样
- 同一个进程的线程,共享虚拟内存,只需要切换线程的西游数据,寄存器等不共享的数据

## 线程的实现
- *用户线程*  在用户空间实现的线程,不是由内核管理,而是用户态的线程库来完成线程的管理(TCB线程管理块由用户库函数维护)
- *内核线程*  在内核中实现的线程,是由内核管理的线程(TCB线程管理块在内核由系统维护)
- *轻量级线程*  在内核中来支持用户线程

用户线程的优点
- 每个进程都需要它私有的线程控制块(TCB列表),用来跟踪记录各个线程状态信息,TCB由用户级线程库函数来维护可用于不支持线程技术的操作系统
- 用户线程的切换无需用户态和内核态的切换,速度很快
用户线程的缺点
- 操作系统不参与线程的调度,如果一个线程发起了系统调用而阻塞,进程所包含的用户线程都不能执行
- 当一个线程开始运行后,除非它主动交出CPU的使用权,否则它所在的进程当中的其它线程无法有哪些,用为用户态的线程没法打断当前运行的线程,只有操作系统才有,但是用户线程不是由操作系统管理的

内核线程的优点
- 一个进程中如果某个内核线程阻塞,不会影响其它内核线程的运行
- CPU运行时间更多
内核线程的缺点
- 系统开销较大

****
# 调度
****
选择一个进程运行这一功能是在操作系统完成的,通常称为调度程序(scheduler)

## 调度时机
当进入从一个运行状态到另一状态变化的时候,会触发一次调度
- 就绪态->运行态  当进程被创建时,会进入到就绪队列,操作系统会从就绪队列选择一个进程运行
- 运行态->阻塞态  操作系统必须选择另一个进程运行
- 运行态->结束太  操作系统选择另一个进程运行

调度算法的分类
- 非抢占式调度算法 不会处理时钟中断,让进程运行知道阻塞或退出
- 抢占式调度算法 也就是时间片机制

调度原则
- *原则一*  发生I/O事件时为提高CPU利用率,需要调度程序选择一个进程运行
- *原则二*  调度程序要权衡长任务和短任务进程的运行完成数量,提高系统吞吐率
- *原则三*  调度程序要避免进程的等待时间很长而运行时间很短
- *原则四*  调度程序要考虑就绪队列中进程的等待时间
- *原则五*  交互式比较强的应用,调度程序需要考虑响应时间
![[Pasted image 20250507112925.png]]

## 调度算法
单核CPU系统中常见的调度算法
1. 先来先服务调度算法
2. 最短作业优先调度算法。优先选择运行时间最短的进程来运行
3. 时间片轮转调度算法  每个进程被分配一个时间段，称为时间片
4. 最高优先级调度算法
5. 多级反馈队列算法