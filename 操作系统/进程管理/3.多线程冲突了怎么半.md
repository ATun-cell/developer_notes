对于共享资源，如果没有上锁，在多线程的环境里，那么就可能会发生翻车现场

# 竞争与协作
****
并发中存在得线程协同问题，两个线程共同准备修改一个变量时，一个线程在将寄存器结果写回到内存之前可能因为时钟中断，导致内存中变量值没有更新，另一个线程则成功更新变量值，导致变量得值最终和预计得有偏差。
总结来说就是*多个线程竞争共享资源，如果不采取有效的措施，则会造成共享数据得混乱*

## 互斥得概念
上面展示得情况称为竞争条件。
由于多线程执行操作共享变量得这段代码可能会导致竞争状态，因此我们将此段代码称为*临界区*，它是共享资源得代码片段，一定不能给多线程同时执行。这段代码执行过程中最多只能出现一个线程，也就是对于线程来说是互斥得。
另外当多进程竞争共享资源的时候出现临界区，也是可以使用互斥的方式来避免造成资源混乱

## 同步的概念
所谓同步，就是并发进程/线程在一些关键点上可能需要相互等待互通消息，这种相互制约的等待与互通消息称为进程/线程同步
****
# 互斥与同步的实现和使用
****
主要的方法有两种
- **锁**  加锁、解锁操作
- **信号量**  p、v操作

## 锁
任何向进入临界区的线程，必须先执行加锁操作。若加锁操作顺利通过则可进入临界区，在完成对临界区资源的访问后再执行解锁操作，以释放该临界资源

根据锁的实现方式不同，可以分为*忙等待锁*和*无忙等待锁*

- 忙等待锁 获取不到锁时线程会一直while循环，不做任何事情，所以被称为忙等待锁也被叫做自旋锁
- 无等待锁就是获取不到锁的时候不用自旋，把当前线程放到锁的等待队列然后执行调度程序把cpu让给其它线程执行

## 信号量
信号量表示资源的数量，对应的是一个整型变量
- P操作，信号量减1，如果信号量小于0，则线程进入阻塞等待，否则继续，表明P操作可能会阻塞
- V操作，将信号量加1，如果信号量小于等0，唤醒一个等待中的线程，表明V操作不会阻塞
P操作时用在进入临界区前，V操作是用在离开临界区后，这两个操作必须是成对出现的。
可想而知信号量可以实现互斥，设置信号量为1

*另外还可以用信号量实现*
同步方式是设置一个信号量，初值为0

## 生产者-消费者问题

![[Pasted image 20250508200531.png]]
- 生产者再生成数据后，放在一个缓冲区中，
- 消费者从缓冲区取出数据处理
- 任何试可只能由一个生产者或消费者可以访问缓存区

*分析*
- 操作缓存区是临界代码，需要互斥
- 缓冲区空时，消费者必须等待生产者生成数据；缓冲区满时，生产者必须等待消费者取出数据。说明需要同步
*设置三个信号量*
- 互斥信号量mutex  初始化值为1
- 资源信号量fullbuffers  用于消费者询问换成去是否有数据。初始化为0，表明缓冲区一开始为空
- 资源信号量emptybuffers  用于生产者徐文缓冲区是否有空位，初始化值为n，表明缓冲区大小
![[Pasted image 20250508201318.png]]


## 哲学家就餐问题
![[Pasted image 20250508202111.png]]

问题描述
- 5个老大哥哲学家，围这一张圆桌吃面
- 桌子只有五只叉子，每两个哲学家之间防一支
- 哲学家围在一起思考，思考中途饿了就会想进餐
- 每个哲学家要两只叉子才愿意吃面
- 吃完后会把两只叉子放回原处
如何保证哲学家们的动作有序进行，而不会发生有人永远拿不到叉子
*方案一*：
设置五个信号量初始化为1，每个哲学家进餐前后分别执行两次p,v操作
但是存在一个极端问题，每个进程都卡死在只执行完第一次P操作的时刻，这时信号量为0，所有进程阻塞在第二步p操作的时候。具象来说就是每个人只有一只手拿到了叉子

*方案二*：
在每次拿叉子前加上互斥信号量
![[Pasted image 20250508203513.png]]
这样会同一时间只有一个人能吃到饭，但是五个叉子能保证两个人一块吃饭，造成效率低下

*方案三*
方案一的问题是所有人会同时拿起相同边的叉子。我们可以把哲学家分编号，让偶数编号的哲学家，先拿左边的叉子，奇数编号的哲学家先拿右边的叉子
![[Pasted image 20250508204030.png]]
这样可以使两个人同时用餐，不会发生死锁

## 读者-写者问题
哲学家进餐问题对于互斥访问有限的竞争问题一类的建模过程十分有用
读者-写者问题为数据库访问建立了一个模型
读者-写着问题描述
- 读-读 允许，同一时刻允许多个读者同时读
- 读-写 互斥，没有写者时读者才能读，没有读者时写者才能写
- 写-写 互斥，没有其它写着时，写者才能写
*方案一*  读者优先策略
- 信号量wMutex 控制写操作的互斥信号量，初始化为1
- 读者计数rCount 正在进行读操作的读者个数，初始化为0
- 信号量rCountMutex 控制对rCount读者计数器的互斥修改，初始化为1
![[Pasted image 20250508205352.png]]
*方案二*  写者优先策略
- 只要有写者准备进入，写者应尽快执行写操作，后来的读者就必须阻塞
- 如果有写者持续不断写入，则读者就处于饥饿
在方案一的技术上新增如下变量：
- rMutex 控制读者进入互斥信号量，初始值为1
- wDataMutex 控制写者写操作的互斥信号量，初始值为1
- wCount 记录写者数量，初始值为0
- wCountmutex 控制wCount互斥修改，初始值为1
![[Pasted image 20250508210458.png]]
注意这一rMutex的作用，开始有多个读者读数据，全部进入读者队列，此时一来写者读者就阻塞了，所以后续写者能全部进入写者队列，而且写者队列的人走完了之后读者才能进入读者队列

*方案三* 双方公平策略
![[Pasted image 20250508211408.png]]
方案一为什么读者优先，就是因为只要读者队列还有人那么写者就无法进入，但是读者可以源源不断的进入没有任何限制，限制flag信号量的加入，使得只要来了一个写者，后续读者进程就会阻塞，读者计数器不会逐渐增加只会逐渐减少，没有读者时，会唤醒写者进程，写者就不必等待源源不断的读者进程。