进程之间共享内核空间，多以要通信必须通过内核

# 管道
****
*匿名管道*  Linux命令的|就是匿名管道，管道的数据传输时单向的，想要相互通信，需要两个管道
*命名管道*  叫做FIFO

管道这种通信方式，只有当管道中的数据被读完后，命令才可以正常退出。可以看出这种通信方式效率低下，不适合进程间频繁的交换数据，好处是简单，而且很容易得知管道里的数据已经被另一个进程读取了

其实，管道就是内核里面的一串缓存。从管道写入的数据是缓存在内核中的，管道的另一段读取也就是从内核中读取这段数据。管道传输的数据是无格式的流且大小首先
对于匿名管道，通信范围是存在父子关系的进程，因为管道没有实体，也就是没有管道文件，只能通过fork来复制父进程fd文件描述符来达到通信的目的
对于命名管道，它可以在不想管的进程间也能相互通信。因为明明管道提前创建了一个类型为管道的设备文件，在进程里只要是哟个这个文件，就可以相互通信
****
# 消息队列
****
比管道更适合频繁的进程间数据交换
*消息队列就是保存在内核中的消息链表*  在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），不像是管道是五个师的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除
消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一致存在。而管道的生命周期是随进程的创建而建立，随进程的结束而销毁
消息这个模型，两个进程之间的通信就像平时发送邮件一样，可以频繁沟通了
*不足之处有两点* 
- 通信不及时
- 附件也有大小限制
所以不适合比较大的数据的传输，因为内核中每个消息体都有一个最大长度的限制。同时所有队列所包含的所有消息体的长度也是有上限。
消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销，因为进程写入数据到内核中的消息队列时会发生从用户态开背数据到内核态的工程。读取内核态的数据也是如此
****
# 共享内存
****
共享内存解决了用户态和内核态之间的消息拷贝过程
共享内存的机制就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了
****
# 信号量
****
共享内存有可能带来多进程通信间的冲突
需要信号量来保护共享资源，以确保任何时刻只能由一个进程访问共享资源，这种方式就是互斥访问。信号量不仅可以实现访问的互斥性，还可以实现进程间的同步，信号量其实是一个计数器，表示的是资源的个数，
****
# 信号
****
信号时间的来源只要有硬件来源和软件来源
信号是进程间通信机制中唯一的异步通信机制，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种用户进程对信号的处理方式
1. 执行默认操作
2. 捕捉信号
3. 忽略信号
****
# Socket
****
跨网络与不同主机上的进程之间通信，就需要SOcket通信
 - 基于TCP协议的通信
 - 基于UDP协议的通信
 - 本低进程间通信