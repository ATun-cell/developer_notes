高并发场景下，一般在访问共享资源之前都会加锁，针对不同的场景，需要选择合适的锁
# 互斥锁和自旋锁
****
底层的锁
当一个线程加锁之后，其它线程加锁就会失败，但是*互斥锁*和*自旋锁*对于加锁失败后的处理方式是不一样的
- 互斥锁 ：线程会释放CPU给其它线程
- 自旋锁： 线程会忙等待，直到拿到锁

互斥锁加锁失败而阻塞的现象，会从永和太陷入到内核态，让内核帮我我们切换线程，这种方式有两次线程上下文切换的开销成本
- 加锁失败时，内核会把线程状态设置为睡眠状态
- 当锁被释放时，之前的睡眠状态的线程会变为就绪状态，内核会在合适的时间把CPU切换给该线程运行

**所以**，能保证被锁住的代码执行时间很短，就不该用互斥锁，而应该用自旋锁，因为可能线程上下文切换的时间比被锁住的代码的执行时间还久

自旋锁是通过CPU提供的CAS函数在用户态完成加锁和解锁操作，不会导致线程上下文切换
CAS函数把一般加操作合并为一条硬件级指令，形成原子指令，要么一次性执行完两个步骤，要么两个步骤都不执行
****
# 读写锁
分为读锁和写锁
适用于能明确区分读操作和写操作的场景。工作原理是：
- 当写锁没有被线程持有时，多个线程能够并发的持有读锁，大大提高了共享资源的访问效率，因为读锁时用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据
- 但是一旦写锁被线程持有后，读线程的获取读锁的操作会被阻塞，其它线程获取写锁的操作也会被阻塞
这里需要注意的是，读锁是共享锁，可以被多个线程同时获取
分为读优先锁
公平读写锁
****
# 乐观锁与悲观锁
****
前面的都是悲观锁
悲观锁做事比较悲观，认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，因此要先上锁
那如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁

乐观锁假定冲突的概率很低，它的工作方式是：先修改完共享资源，在验证这段时间有没有发生冲突，如果没有其它线程在修改资源，那么操作完成，如果发现有其它线程已经修改过这个资源就放词本次操作
乐观锁全程并没有加锁所以它也叫无锁编程