传统的LRU算法粗在这两个问题：
- *预读失效*  导致缓存命中率下降
- *缓存污染*  导致缓存命中率下降
redis的缓存淘汰算法是通过实现LFU算法来避免*缓存污染*（没有预读机制）
MySQL和Linux系统是通过改进LRU算法
这次是讲MySQL和Linux是如何改进LRU算法

# Linux和MySQL的缓存
****
## Linux操作系统的缓存
应用程序读取文件数据的时候，Linux会对读取的文件数据进行缓存，在文件系统的Page Cache(页缓存)
![[Pasted image 20250505221433.png]]

## MySQL的缓存
MySQL的数据是存在磁盘中的，为了提升读写性能，lnnodb存储引擎设计了一个*缓存池*（Buffer Pool）。有了缓存池后
- 读取数据时，如果数据存在Buffer Pool中，客户端就会直接读取，否则去磁盘读取
- 修改数据时，首先修改Buffer Pool数据所在的页，设置为脏页，最后由后台线程将脏页写入到磁盘中

# 传统LRU算法
****
常用的内存管理算法实现频繁访问的内存留在内存中，很少访问的数据可以在某些时机被淘汰掉，一般用到的是LRU(Least recently used)算法

LRU算法一般是用*链表*实现的，链表的头部数据是最近使用的，末尾是最久没被使用的，当物理内存空间不够了，淘汰链表末尾的数据。算法的实现思路是
- 当访问的页在内存里，直接把该页对应的LRU链表节点移动到链表的头部
- 当访问的页不在内存里，除了要把该页放入LRU链表的头部，还要淘汰LRU链表末尾的页
![[Pasted image 20250506111430.png]]
****
# 预读失效怎么半
****
## 什么是预读机制
Linux为基于Page Cache的读缓存机制提供预读机制，应用程序想在磁盘读一个block(大小刚好匹配内存中Page)，但是处于空间局部性原理（靠近当前被访问数据的数据，在未来很大概率会被访问到），会选择将后续一定范围内的数据都加载到内存中，额外在内存中申请3个Page。
这样做可以减少磁盘读写频率，MySQL中的buffer pool也有类似的机制

## 会带来什么问题
**预读失效**：提前加载进来的页没有被访问，降低缓存命中率，就是预读失效

如果使用LRU算法，就会把预读页梵高LRU链表头部，
如果这些预读页不会被访问当，就会出现，不会被访问的预读页占用链表前排的位置，而末尾淘汰的页可能是热点数据

## 怎么避免预读失效带来的问题
*对LRU链表做改进*
- Linux实现了两个LRU链表：活跃LRU链表和非活页LRU链表
- MySQL的Innodb存储引擎在一个LRU链表上划分两个区域：young区域和old区域
两者设计思路一致，都是讲数据分为冷数据和热数据分别进行LRU算法

预读页只需要加入到inactive list区域的头部，当页被真正访问的时候，才将页插入到active list的头部
****
# 缓存污染怎么半
****
## 什么是缓存污染
如果使用*数据被访问一次，就将数据加入到活跃LRU链表头部这种方式的话*。这时如果批量读取数据，这些数据会占慢活页LRU链表的空间，导致之前缓存在活页LRU链表里的热点数据全都被淘汰，并且批量读取的数据未来长时间不会被再次访问，这时称活跃LRU链表被污染了

## 怎么避免缓存污染造成的影响
只要数据被访问一次，就加入到活页LRU链表，这样的门槛太低了
- Linux:内存第二次被访问的时候，才从inactive list升级到active list
- MySQL：内存页被访问第二次的时候，
	- 如果两次访问时间在1秒内，那么该页不会升级
	- 如果两次访问时间超过1秒，该页升级到young区域
