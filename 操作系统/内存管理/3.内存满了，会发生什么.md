首先第一个问题，**虚拟内存有什么用**
- 第一，CPU访问内存有很明显的重复访问的倾向性，对于不经常被访问的内存，可以换到物理内存之外，比如硬盘上的swap区域
- 第二，每个经常的虚拟内存是相互独立的（独立的页表），解决了多进程之间地址冲突的问题
- 第三，页表中的页表项除了物理地址之外还有一些标记属性，比如读写权限，是否有效等。在内存访问方面更安全。

然后来了解第二个问题，**系统内存紧张时会发生什么**

# 内存分配的过程
****
应用程序通过malloc函数申请内存的时候，申请的是虚拟内存，并不会分配物理内存

应用程序读写被分配的这块虚拟内存时，CPU会去访问这块虚拟内存，会发现这个虚拟内存没有映射到物理内存，CPU就会产生*缺页中断*，进程会从*用户态切换到内核态*，并将缺页中断交给内核的Page Fault Handler(缺页中断函数)处理，建立虚拟内存与物理内存之间的映射关系。
这时如果没有空闲的物理内存，内核就会开始进行回收内存的工作，两种方式
- *后台内存回收*（kswapd）：kswapd内核线程是异步的，不会阻塞进程的执行
- *直接内存回收*（direct reclaim）：如果后台内存回收跟不上内存申请的速度，就会开始直接回收，这个过程是同步的会阻塞进程的执行

如果此时仍无法满足此次物理内存的申请，那么内核就会来时触发**OOM(Out of Memory)** 机制
OOM机制会根据算法选择一个占用内存较高的进程，将其杀死，如果还不够，继续杀

# 哪些内存可以被回收
****
有两类，各自回收方式也不一样
- 文件页的回收：对于干净页是直接释放内存的，对于脏页会先写到磁盘再释放内存
- 匿名页的回收：如果开启了swap机制，那么swap会将补偿访问的匿名页换出到磁盘中
****
# 回收内存带来的性能影响
****
回收内存的操作基本都会发生磁盘I/O的，会影响系统的性能
常见的解决方式有
## 调整文件页和匿名页的回收倾向
文件页的回收操作对系统的影响会小一点，因为干净页是直接释放，不会发生磁盘读写操作
## 尽早触发kswapd内核线程异步回收内存
****
# 如何保护一个进程不被OOM杀掉
****
内核会对每个进行打分，得分最高的进程会被首先杀掉，得分受下面两点影响
- 进程已经使用的物理内存页面数
- 每个进程的OOM校准值oom_score_adj。我们可以调整来调整进程被烧掉的几率
