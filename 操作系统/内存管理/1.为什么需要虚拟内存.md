# 虚拟地址
****
程序在访问内存时，操作系统为每个进程分配独立的**虚拟地址空间**，并通过地址映射机制将虚拟地址转换为物理地址。这样可以确保不同进程访问的是不同的物理内存区域，从而避免冲突和相互干扰。

操作系统如何管理虚拟地址与物理地址之间的关系，主要有两种方式，内存分段和内存分页。

## 内存分段

程序是由若干个逻辑分段组成的，代码分段，数据分段等等，不同的段有不同的属性，所以就用分段的形式把这些段分离出来
分段机制下，虚拟地址由两部分组成，段选择银子和段内偏移量
- *段选择因子*  保存在段寄存器里面。里面最重要的是段号，用作段表的索引。段表里面是这个段的及地址、段的界限和特权等级等
- *段内偏移量*  介于0和段界限之间，段基地址加上段内偏移量得到物理内存地址

 这样的机制会导致的问题：内存碎片和内存交换效率低
- *内存碎片*  分为程序内部内存碎片和外部内存碎片，内存分段会导致外部内存碎片的问题。解决的方法就是内存交换。
- *内存交换效率低*  每一次内存交换都要把一大段连续的内存数据写到硬盘上，造成效率低

## 内存分页
分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这养一个连续且尺寸固定的内存空间叫做页。
虚拟地址和物理地址之间通过页表来映射
![[Pasted image 20250502200449.png]]

如何映射如下图
![[Pasted image 20250502201323.png]]
### 多级分页
每个进程有自己的虚拟地址空间，都需要一个覆盖全部虚拟地址空间的页表，进程多了之后，页表占用的空间很大。其中的问题是一个进程用不到全部的虚拟地址空间，但是单级页表还是覆盖全部虚拟地址，产生大部分的无效映射，因此设计了一个多级分页。
大概的思路就是 32位的环境下覆盖全部物理地址需要100万个页，每个页4个字节。单级分页把一个页表号对应一个物理页，多级分页把一级页表号对应下一级页表，这样就可以用一个级页表号覆盖到全部的物理地址（中间还要经过中间级页表的多级映射才能找到地址），这样就可以只创建程序使用到的后续页表，大大的节省了页表的占用空间。

### TLB
多级页表虽然解决空间上的问题，但是带来时间上的问题
*TLB是存储最常访问的几个页表的Cache*，通常称为页表缓存或转址旁路缓存或快表

****
## 段页式内存管理
分段和分页不矛盾
- 先把程序划分为有逻辑意义的段
- 再把每个段划分为页
需为每个程序设计一个段表，每个段表设计一个页表