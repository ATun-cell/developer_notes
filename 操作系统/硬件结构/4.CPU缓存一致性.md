
# CPU Cache 的数据写入
****
除了访问数据时要保证缓存命中率高。还要注意写操作时Cache和内存中数据的一致性，那么该在什么时机把Cache中的数据写回到内存中，有两种方法：**写直达（Write Through）、写回（Write Back）**
## 写直达
*把数据同时写入内存和Cache中*
无论数据在不在Cache中，每次写操作都会写回到内存，会花费大量的时间

## 写回
*当发生写操作时，新的数据仅仅被写入到Cache Block中，只有当修改过的Cache Block被替换时才需要写到内存中。减少写回内存的频率。*
具体怎么做到的：
- 发生写操作时，数据已经在Cache里则把数据更新到Cache里，同时标记这个Cache Block为dirty， 这个脏的标记代表这个时候Cache里的数据和内存是不一致的，这种情况不需要把数据写到内存
- 当发生写操作时，数据所对应的Cache Block存放的时别的内存地址的数据的话就要检查这个Cache Block里的数据有没有被标记为脏的：
	- 如果是脏的，就要把这个Cache Block里的数据写回到内存，然后再把当前要写入的数据先从对应内存位置读入到Cache Block里，然后再把当前要写入的数据写入到Cache Block中并标记为脏的
	- 如果不是脏的，把当前要写入的数据从内存读入到Cache Block里，接着将数据写入到这个Cache Block里，然后标记为脏的
写回这个方法只有在缓存不命中，同时数据对应的Cache中的Cache Block标记为脏的情况下才会将数据写到内存。
****
# 缓存一致性问题
****
多核CPU Cache（L1 Cache, L2Cache）不一致带来的问题。如果A核心执行运算操作修改了某个变量的值，那么由于写回操作，修改的知识A核心Cache中的数据，B核心从内存中读这个数据的值将会返回错误的结果。表现出来是不同核心的缓存不一致。
解决缓存不一致需要做到两点：
- *写传播*  某个核心Cache的更新后，需要同步到其它核心
- *事务串行化*  所有核心必须以相同的顺序观察某个变量的操作，确保变量状态的一致演变。
	- 做到事物的串行化，需要做到
	- 1、核心对Cache数据的操作需要同步给其它核心
	- 2、引入*锁*的概念，假设两个核心有相同数据的Cache，那么对这个数据的更新只有拿到了锁才能进行对应的数据更新。

## 总线嗅探
总线嗅探是最常见的*写传播*的实现方式。每个核心都时刻监听总线上的一切活动。

## MESI协议
用四个状态来标记Cache line
- *已修改*  就是之前提到的脏标记
- *已失效*  数据失效，不可以读取该状态的数据
- *独占*  和*共享*  都代表Cache Block里的数据是干净的，就是缓存和内存里的数据是一致的。区别在于独占的数据只在一个核心里存在，不需要考虑缓存一致性，而共享的数据需要考虑缓存一致性
通过四种状态的标记和总线嗅探，达到缓存一致性的效果。

